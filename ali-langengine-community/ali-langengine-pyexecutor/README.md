# ali-langengine-pyexecutor: A Secure Python Code Execution Sandbox for the JVM

## Introduction

`ali-langengine-pyexecutor` is a powerful Java library designed to provide a secure and isolated environment for executing Python code. It is specifically engineered as a sandboxed plugin for AI agents and applications, allowing them to safely run Python scripts generated by Large Language Models (LLMs) or provided by users without compromising the host system.

The library achieves security through process-level isolation and fine-grained control over resources and permissions, such as network access, file system operations, and module imports.

## Core Features

- **Strong Security Sandbox**: Each Python script runs in a dedicated, sandboxed process with strict security policies.
- **Resource Limitation**: Enforce limits on CPU time, memory usage (address space), and the number of open file descriptors to prevent resource exhaustion attacks.
- **Permission Control**:
    - **Network Access**: Disable networking by default to prevent unauthorized external communication.
    - **File System Access**: Restrict file system operations, allowing for "no access", "read-only access within a sandboxed directory", or "full access" based on configuration.
    - **Module Import Control**: Utilize a whitelist or blacklist to control which Python modules can be imported, preventing the use of dangerous libraries like `os`, `subprocess`, or `ctypes`.
- **Dual Execution Modes**:
    - **Stateless (`executeOnce`)**: Ideal for running untrusted, single-use scripts. Each execution spawns a new, clean Python process, ensuring maximum isolation.
    - **Stateful (Session-based)**: Perfect for interactive scenarios where state must be maintained across multiple code executions. A persistent Python daemon process is used for each session, allowing variables and context to be preserved.
- **Session Management**: Includes features like idle timeout (TTL), hard lifetime limits, and maximum session count eviction (LRU) to manage resources efficiently.
- **Seamless Spring Boot Integration**: Provides auto-configuration for easy integration into Spring Boot applications. Simply add the dependency and configure it in your `application.properties`.

## Getting Started

### Prerequisites

- Java 17 or later
- Apache Maven 3.6+
- A Python 3 interpreter available in your system's PATH or specified via configuration.

### Installation

Add the following dependency to your `pom.xml`:

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>ali-langengine-pyexecutor</artifactId>
    <version>1.2.6-202508111516</version> 
</dependency>
```

## Usage Guide

You can use `PyExecutor` in a standalone Java application or integrate it with Spring Boot.

### Quick Start (Standalone Main Method)

This is the most direct way to understand how the library works. The following example demonstrates stateless execution, stateful sessions, and error handling.

```java
package com.alibaba.langengine.pyexecutor.examples;

import com.alibaba.langengine.pyexecutor.PyExecutor;
import com.alibaba.langengine.pyexecutor.PyExecutionPolicy;
import com.alibaba.langengine.pyexecutor.PyExecutionResult;
import com.alibaba.langengine.pyexecutor.SessionConfig;

public class PyExecutorDemo {

    public static void main(String[] args) {
        // 1. Configure the Execution Policy
        PyExecutionPolicy policy = new PyExecutionPolicy();
        policy.setPythonBin("python3"); // Use absolute path if not in PATH
        policy.setTimeout(java.time.Duration.ofSeconds(10));
        
        // 2. Configure the Session Manager for stateful execution
        SessionConfig sessionConfig = new SessionConfig();
        sessionConfig.setWorkspaceRoot(System.getProperty("java.io.tmpdir"));

        // 3. Create the PyExecutor Instance
        PyExecutor pyExecutor = new PyExecutor(policy, sessionConfig);

        System.out.println("PyExecutor Demo Started.\n");

        // Run all examples
        runStatelessExample(pyExecutor);
        runStatefulSessionExample(pyExecutor);
        runErrorHandlingExample(pyExecutor);

        System.out.println("\nPyExecutor Demo Finished.");
    }

    /**
     * Demonstrates oneshot (stateless) execution.
     */
    public static void runStatelessExample(PyExecutor pyExecutor) {
        System.out.println("--- Running Stateless (executeOnce) Example ---");
        try {
            String code = "a = 5\nb = 10\na * b";
            PyExecutionResult result = pyExecutor.executeOnce(code, null);

            if (result.getExitCode() == 0) {
                System.out.println("Execution successful. Last expression value: " + result.getLastValueRepr());
            } else {
                System.err.println("Execution failed: " + result.getErrorRepr());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("-------------------------------------------------\n");
    }

    /**
     * Demonstrates session-based (stateful) execution.
     */
    public static void runStatefulSessionExample(PyExecutor pyExecutor) {
        System.out.println("--- Running Stateful (Session) Example ---");
        String sessionId = "my-interactive-session";
        try {
            System.out.println("Step 1: Defining variable 'my_list'");
            pyExecutor.execute(sessionId, "my_list = [1, 2, 3]", null);

            System.out.println("Step 2: Appending a value to 'my_list'");
            PyExecutionResult result = pyExecutor.execute(sessionId, "my_list.append(4); my_list", null);

            if (result.getExitCode() == 0) {
                System.out.println("Execution successful. New list value: " + result.getLastValueRepr());
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            System.out.println("Step 3: Closing session");
            pyExecutor.closeSession(sessionId);
        }
        System.out.println("--------------------------------------------\n");
    }

    /**
     * Demonstrates error handling.
     */
    public static void runErrorHandlingExample(PyExecutor pyExecutor) {
        System.out.println("--- Running Error Handling Example ---");
        try {
            String badCode = "result = 1 / 0";
            PyExecutionResult result = pyExecutor.executeOnce(badCode, null);

            System.out.println("Execution finished. Analyzing results...");
            System.out.println("   Exit Code: " + result.getExitCode());
            System.out.println("   Error Repr: " + result.getErrorRepr());
            System.out.println("   Stderr contains traceback: " + (result.getStderr() != null && !result.getStderr().isEmpty()));
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println("--------------------------------------\n");
    }
}
```

### Spring Boot Integration

The library provides auto-configuration for effortless integration.

**1. Configure `application.properties`**

Add your desired configurations to `src/main/resources/application.properties`.

```properties
# =============================================
# ALIBABA LANGENGINE PYEXECUTOR CONFIGURATION
# =============================================

# Path to the Python interpreter. Use an absolute path if necessary.
# e.g., /usr/bin/python3 or C:/Python39/python.exe
ali.langengine.pyexecutor.python-bin=python3

# Global execution timeout (e.g., 10 seconds)
ali.langengine.pyexecutor.timeout=10s

# Disable network access (default: true, highly recommended for security)
ali.langengine.pyexecutor.disable-networking=true

# Enable session mode (default: true)
ali.langengine.pyexecutor.session-enabled=true

# Root directory for session workspaces (defaults to system temp dir)
# ali.langengine.pyexecutor.workspace-root=/path/to/your/workspaces

# Maximum number of concurrent sessions
ali.langengine.pyexecutor.session-max-count=20

# Evict sessions after 15 minutes of inactivity
ali.langengine.pyexecutor.session-idle-ttl=15m
```

**2. Inject and Use `PyExecutor`**

The `PyExecutor` bean will be automatically created. You can inject it directly into your services or components.

```java
@Service
public class MyAiService {

    private final PyExecutor pyExecutor;

    @Autowired
    public MyAiService(PyExecutor pyExecutor) {
        this.pyExecutor = pyExecutor;
    }

    public String executePythonForAi(String pythonCode) throws Exception {
        // Use a unique session ID for each user or conversation
        String sessionId = "user-conversation-abc-123";
        PyExecutionResult result = pyExecutor.execute(sessionId, pythonCode, null);

        if (result.getErrorRepr() != null) {
            return "Error: " + result.getErrorRepr();
        }
        return result.getLastValueRepr();
    }
}
```

## Configuration Details

You can fine-tune the execution environment using `PyExecutionPolicy` (for standalone use) or through `application.properties` (for Spring Boot).

| Property (`ali.langengine.pyexecutor.*`) | Default | Description |
|------------------------------------------|---------|-------------|
| `python-bin`                             | `python3` | Path to the Python executable. |
| `timeout`                                | `5s`    | Maximum wall-clock time for an execution. |
| `cpu-time-seconds`                       | `2`     | (UNIX-like) Max CPU time in seconds. Triggers before wall-clock timeout. |
| `address-space-bytes`                    | `536870912` (512MB) | (UNIX-like) Max memory address space. |
| `disable-networking`                     | `true`  | If true, blocks all network-related syscalls. |
| `disable-open`                           | `true`  | If true, disables the `open()` built-in function completely. |
| `allow-readonly-open`                    | `false` | If `disable-open` is false, setting this to true restricts `open()` to read-only mode within the sandboxed CWD. |
| `use-import-whitelist`                   | `true`  | If true, only modules in `allowed-imports` can be imported. If false, modules in `banned-imports` are blocked. |
| `allowed-imports`                        | (Set of safe modules) | Comma-separated list of modules allowed in whitelist mode. |
| `banned-imports`                         | (Set of dangerous modules) | Comma-separated list of modules blocked in blacklist mode. |
| `session-enabled`                        | `true`  | Enables or disables the session execution mode (`execute` method). |
| `session-max-count`                      | `50`    | Maximum number of concurrent sessions. Oldest inactive sessions are evicted. |
| `session-idle-ttl`                       | `10m`   | Duration after which an inactive session is evicted. |
| `session-hard-ttl`                       | `1h`    | Maximum lifetime of a session, regardless of activity. |

## How It Works

The library operates by launching Python processes and communicating with them over standard streams (`stdin`, `stdout`, `stderr`).

1.  **Prelude Script**: A special Python "prelude" script is generated on the fly. This script sets up the security sandbox (hooks into `import`, `open`, etc.) and prepares to receive commands.
2.  **Process Launch**:
    - For `executeOnce`, a new Python process running the prelude script is started for every call.
    - For `execute`, a persistent Python daemon process is started and managed for each session.
3.  **Communication**: The Java code sends the user script and options as a JSON message to the Python process's `stdin`.
4.  **Execution & Response**: The Python prelude script executes the user code, captures the result or any error, and prints it back to `stdout` as a structured JSON message.
5.  **Result Parsing**: The Java library reads the JSON response from the process's `stdout`, parses it into a `PyExecutionResult` object, and returns it to the caller.

This process-based sandboxing model provides a high level of security, as the Python code has no direct access to the JVM's memory or resources.

## License

This project is licensed under the **Apache License 2.0**.